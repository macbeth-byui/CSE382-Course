<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lesson11.md</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#cse-382-lesson-11---tries">CSE 382 Lesson 11 - Tries</a>
<ul>
<li><a href="#part-1---tries">Part 1 - Tries</a></li>
<li><a href="#problem-set-1">Problem Set 1</a></li>
<li><a href="#part-2---searching-and-counting">Part 2 - Searching and Counting</a></li>
<li><a href="#problem-set-2">Problem Set 2</a></li>
<li><a href="#part-3---performance">Part 3 - Performance</a></li>
<li><a href="#problem-set-3">Problem Set 3</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="cse-382-lesson-11---tries">CSE 382 Lesson 11 - Tries</h1>
<p>When we look at all of the forms of trees (including heaps) we notice that the placement of values is highly dependent on the result of comparing two values.  While comparing two integers can be an easy thing to do, the comparison of two string is more complicated.  Comparing strings is a frequent activity performed in our software but consider the fact that string comparisons at worst will require the comparison of multiple characters each time.  If our strings were stored in a binary search tree, we would need to compare our target string with several other strings until we found a match.  The Trie data structure provides a tree structure which is intended to store strings in such a way that searching is faster and potentially memory storage is optimized.</p>
<p>You can find the template for the problem sets in this lesson here: <a href="https://macbeth-byui.github.io/cse382-course/proves/prove11.erl">prove11.erl</a></p>
<h2 id="part-1---tries">Part 1 - Tries</h2>
<p>The diagram below shows an example of a Trie that stores words.  Notice that the Trie begins with an empty character string and then branches out to all valid first letters for the values that are stored.  Each branch represents a single letter.  To find the words that are stored, you start at the root and progress downwards until you get to a letter that has <code>done</code> as a child.  In many cases, additional words can be found by following other letters instead of stopping at the <code>done</code>.  This Trie includes the words: “day”, “date”, “days”, “”, “cow”, “cold”, “dog”.  Notice that since “” is in the Trie, that there is a <code>done</code> child connected to the root.</p>
<p><img src="https://macbeth-byui.github.io/cse382-course/images/trie1.drawio.png" alt="Trie"></p>
<p>When adding a new word, we start at the root and go one letter at a time.  If the letter already exists in the Trie, then we goto the next letter.  If the letter does not exist, then we create a child for that letter.  The subsequent letters will all be new children.</p>
<p>Unlike the binary search tree, the Trie can have a variable number of children.  We can store those variable number of children in any data structure.  For simplicity, we will use a dictionary as follows:</p>
<blockquote>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">{</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>:</mo><mi>L</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo>↫</mo><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">struct ~ ~ node ~ ~ \lbrace string:Letter \looparrowleft node \rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">{</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">e</span><span class="mord mathnormal">tt</span><span class="mord mathnormal" style="margin-right: 0.02778em;">er</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel amsrm">↫</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">}</span></span></span></span></span></p>
</blockquote>
<p>The diagram below shows the same early Trie but with the perspective of dictionaries.  Each set of boxes represents a separate dictionary.  The arrows represent the <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span></span> value associated with each key in the dictionary.</p>
<p><img src="https://macbeth-byui.github.io/cse382-course/images/trie2.drawio.png" alt="Trie"></p>
<p>Here is the specification for our add function:</p>
<blockquote>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mtext>&nbsp;&nbsp;</mtext><mi>a</mi><mi>d</mi><mi>d</mi><mo>:</mo><mo>:</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>&nbsp;&nbsp;</mtext><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">spec ~ ~ add :: string ~ ~ node \rightarrow node.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord">.</span></span></span></span></span></p>
</blockquote>
<p>When adding to the Trie, there are three scenarios that we must cover:</p>
<ol>
<li>Add a word into an empty Trie - this will require that we create our root node for the empty character.  From this new root node, we will begin to add each letter of the word.</li>
<li>Check each letter (we will represent the word a list of letters)  to see if the letter already exists in the dictionary.
<ul>
<li>If the letter does exist, then follow that node (the next dictionary) and check for the next letter recursively.</li>
<li>If the letter does not exist, then create a new node (with an empty dictionary - <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo>↫</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\lbrace \looparrowleft \rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">{</span><span class="mrel amsrm">↫</span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">}</span></span></span></span></span>) for the letter and add it the current node dictionary.  Follow that new node for the next letter recursively.  Note that once we have this case, all subsequent letters will be new nodes as well.</li>
</ul>
</li>
<li>If we run out of letters, then that means that the node we are on is a terminating node for a word.  The value <code>done</code> should be added to the dictionary of this node.  This is the base case.</li>
</ol>
<p>All three scenarios appear in the definition below.  Note that we are using three functions that we assume exists for a dictionary:</p>
<ul>
<li><code>contains</code> - Does the key exist in the dictionary</li>
<li><code>get</code> - Get the value in the dictionary associated with the key</li>
<li><code>put</code> - Put the key and value into the dictionary</li>
</ul>
<blockquote>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>a</mi><mi>d</mi><mi>d</mi><mo>:</mo><mo>:</mo><mi>W</mi><mi>o</mi><mi>r</mi><mi>d</mi><mtext>&nbsp;&nbsp;</mtext><mi>n</mi><mi>i</mi><mi>l</mi><mo>→</mo><mo stretchy="false">(</mo><mi>a</mi><mi>d</mi><mi>d</mi><mtext>&nbsp;&nbsp;</mtext><mi>W</mi><mi>o</mi><mi>r</mi><mi>d</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">{</mo><mo>↫</mo><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ add :: Word ~ ~ nil \rightarrow (add ~ ~ Word ~ ~ \lbrace \looparrowleft \rbrace).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mord mathnormal" style="margin-right: 0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">ni</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mord mathnormal" style="margin-right: 0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">{</span><span class="mrel amsrm">↫</span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">})</span><span class="mord">.</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>a</mi><mi>d</mi><mi>d</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mtext>&nbsp;&nbsp;when&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mtext>&nbsp;&nbsp;</mtext><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ add :: [] ~ ~ Node \rightarrow Node ~ ~ \text{when} ~ ~ (contains ~ ~ done ~ ~ Node) == true;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord text"><span class="mord">when</span></span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>a</mi><mi>d</mi><mi>d</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mo stretchy="false">(</mo><mi>p</mi><mi>u</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mtext>&nbsp;&nbsp;</mtext><mi>n</mi><mi>i</mi><mi>l</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ add :: [] ~ ~ Node \rightarrow (put ~ ~ done ~ ~ nil ~ ~ Node);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">ni</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>a</mi><mi>d</mi><mi>d</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mo stretchy="false">(</mo><mi>p</mi><mi>u</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>a</mi><mi>d</mi><mi>d</mi><mtext>&nbsp;&nbsp;</mtext><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>g</mi><mi>e</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mtext>&nbsp;&nbsp;when&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mtext>&nbsp;&nbsp;</mtext><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ add :: [First|Rest] ~ ~ Node \rightarrow(put ~ ~ First ~ ~ (add ~ ~ Rest ~ ~ (get ~ ~First ~ ~ Node) ~ ~ Node) ~ ~ \text{when} ~ ~ (contains ~ ~ First ~ ~ Node) == true;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord text"><span class="mord">when</span></span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>a</mi><mi>d</mi><mi>d</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ add :: [First|Rest] ~ ~ Node \rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>p</mi><mi>u</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>a</mi><mi>d</mi><mi>d</mi><mtext>&nbsp;&nbsp;</mtext><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">{</mo><mo>↫</mo><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\kern{2em}(put ~ ~ First ~ ~ (add ~ ~ Rest ~ ~ \lbrace \looparrowleft \rbrace) ~ ~ Node)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">{</span><span class="mrel amsrm">↫</span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mclose">})</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<p>The implementation of the <code>add</code> function will be left for an exercise.</p>
<p>In Erlang, we can use the following code to perform the <code>contains</code>, <code>get</code> and <code>put</code> operations on the dictionary.  In Erlang, a dictionary is called a map  Note that to create an empty map, we use <code>#{}</code>.  If we wanted to prefill the map, we could use <code>#{key1 =&gt; value1, key2 =&gt; value2, key3 =&gt; value3}</code>.</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token variable">Map</span> <span class="token operator">=</span> <span class="token punctuation">#</span><span class="token punctuation">{</span><span class="token string">"Bob"</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"Sue"</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token comment">% contains</span>
<span class="token boolean">true</span> <span class="token operator">=</span> <span class="token atom">maps</span><span class="token punctuation">:</span><span class="token function">is_key</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token variable">Map</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token boolean">false</span> <span class="token operator">=</span> <span class="token atom">maps</span><span class="token punctuation">:</span><span class="token function">is_key</span><span class="token punctuation">(</span><span class="token string">"Tim"</span><span class="token punctuation">,</span> <span class="token variable">Map</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

<span class="token comment">% get</span>
<span class="token number">10</span> <span class="token operator">=</span> <span class="token atom">maps</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token variable">Map</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token number">20</span> <span class="token operator">=</span> <span class="token atom">maps</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Sue"</span><span class="token punctuation">,</span> <span class="token variable">Map</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

<span class="token comment">% put</span>
<span class="token variable">New_Map</span> <span class="token operator">=</span> <span class="token atom">maps</span><span class="token punctuation">:</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Tim"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token variable">Map</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token number">30</span> <span class="token operator">=</span> <span class="token atom">maps</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Tim"</span><span class="token punctuation">,</span> <span class="token variable">New_Map</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</code></pre>
<h2 id="problem-set-1">Problem Set 1</h2>
<ol>
<li>Implement the <code>add</code> function and use the provided test code to verify the implementation.  In the test code note that the pattern matching is done with <code>:=</code> instead of <code>=&gt;</code> in Erlang.  Also recall that Erlang will represent a string as a list of characters where each character is stored using the ASCII table integer value.</li>
</ol>
<h2 id="part-2---searching-and-counting">Part 2 - Searching and Counting</h2>
<p>To search for a word in the Trie, we will check each letter to see if it is contained in the dictionary.  Each check will be a recursive call.  If the current letter is not in the dictionary, then the word does not exist.  When we get through the whole word (base case with []) then we will need to look for <code>done</code> in the dictionary.  If <code>done</code> does not exist, then the original word does not exist.</p>
<p>The specification and definition for the <code>search</code> function is given below:</p>
<blockquote>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mtext>&nbsp;&nbsp;</mtext><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mo>:</mo><mo>:</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext>&nbsp;&nbsp;</mtext><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">spec ~ ~ search :: string ~ ~ node.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">se</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord">.</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mo>:</mo><mo>:</mo><mi>W</mi><mi>o</mi><mi>r</mi><mi>d</mi><mtext>&nbsp;&nbsp;</mtext><mi>n</mi><mi>i</mi><mi>l</mi><mo>→</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ search :: Word ~ ~ nil \rightarrow false;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">se</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">W</span><span class="mord mathnormal" style="margin-right: 0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">ni</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mtext>&nbsp;&nbsp;</mtext><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ search :: [] ~ ~ Node \rightarrow (contains ~ ~ done ~ ~ Node);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">se</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mo stretchy="false">(</mo><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mtext>&nbsp;&nbsp;</mtext><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>g</mi><mi>e</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>&nbsp;&nbsp;when&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mtext>&nbsp;&nbsp;</mtext><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ search :: [First|Rest] ~ ~ Node \rightarrow (search ~ ~ Rest ~ ~ (get ~ ~ First ~ ~ Node)) ~ ~ \text{when} ~ ~ (contains ~ ~ First ~ ~ Node);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">se</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">se</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">h</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">))</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord text"><span class="mord">when</span></span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>s</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>c</mi><mi>h</mi><mo>:</mo><mo>:</mo><mo stretchy="false">[</mo><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ search :: [First|Rest] ~ ~ Node \rightarrow false.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">se</span><span class="mord mathnormal">a</span><span class="mord mathnormal">rc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right: 0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mord">.</span></span></span></span></span></p>
</blockquote>
<p>The Erlang code for <code>search</code> function will be left for an exercise.</p>
<p>To count all the words in a Trie, we need to count all the nodes that have a <code>done</code> key in the dictionary.  This will require recursion through all the keys in the dictionary.  Prior to recusing through the keys in the dictionary, we will first need to determine if this node has a <code>done</code> key.  If it does, then the total count will be 1 plus the whatever is found in the recursive calls to each key in the node dictionary.  Remember that the presence of a <code>done</code> key does not mean that there are no other key’s in the dictionary.</p>
<p>The specification and part of the definition is give below.  The remaining definition and implementation will be left for an exercise.</p>
<blockquote>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mtext>&nbsp;&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>:</mo><mo>:</mo><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">spec ~ ~ count :: node \rightarrow integer.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mord mathnormal" style="margin-right: 0.02778em;">er</span><span class="mord">.</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>:</mo><mo>:</mo><mi>n</mi><mi>i</mi><mi>l</mi><mo>→</mo><mn>0</mn><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ count :: nil \rightarrow 0;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">ni</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="mord">0</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>:</mo><mo>:</mo><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ count :: Node \rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"></mspace><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\kern{2em}part\_of\_problem\_set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"></mspace><mtext>when&nbsp;&nbsp;</mtext><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>s</mi><mtext>&nbsp;&nbsp;</mtext><mi>d</mi><mi>o</mi><mi>n</mi><mi>e</mi><mtext>&nbsp;&nbsp;</mtext><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">\kern{2em}\text{when} ~ ~ (contains ~ ~ done ~ ~ Node) == true;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord text"><span class="mord">when</span></span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ain</span><span class="mord mathnormal">s</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.80952em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mpunct">;</span></span></span></span></span></p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mtext>&nbsp;&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>:</mo><mo>:</mo><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>→</mo></mrow><annotation encoding="application/x-tex">de\mathit{f} ~ ~ count :: Node \rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathit">f</span><span class="mspace nobreak">&nbsp;</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="2em"></mspace><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\kern{2em}part\_of\_problem\_set.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathnormal">se</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span></p>
</blockquote>
<h2 id="problem-set-2">Problem Set 2</h2>
<ol>
<li>Implement the <code>search</code> function and use the provided test code to verify the implementation.</li>
<li>Implement the remainder of the <code>count</code> function and use the provided test code to verify the implementation.  Some additional information:
<ul>
<li>In the starting code provided, you will note the following pattern matching syntax <code>count(Node = #{done := nil}) -&gt;</code> which will match if the Node map provided contains a Key called <code>done</code> with a value of <code>nil</code>.  This will still match even if there are other key value pairs stored in the map.  Note that each time we match this pattern we should be adding 1 to the accumulated count.</li>
<li>You may find the <code>maps:fold</code> function useful.  In the same way that <code>lists:foldl</code> will call a lambda function to obtain an accumulated value from a list of values, the <code>maps:fold</code> will call a lambda function to obtain an accumulated value from a list of keys in the map.  The lambda function for the <code>maps:fold</code> takes 3 parameters including the Key, Value, and previous Accumulator value.  The <code>maps:fold</code> function can be used to iterate recursively through all the key value pairs in the Node map.</li>
</ul>
</li>
</ol>
<h2 id="part-3---performance">Part 3 - Performance</h2>
<p>A Trie has the potential to both run faster and use less memory.  If we had a collection of strings to store and we wanted to maximize performance, the following table can be consulted.  Note that <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> represents the number of strings and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">m</span></span></span></span></span> represents the maximum size of the string.</p>

<table>
<thead>
<tr>
<th>Data Structure</th>
<th>Search Timing</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> - Have to search each node and compare each letter</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></td>
</tr>
<tr>
<td>Binary Search Tree</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> if unbalanced; <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext>&nbsp;</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m * log ~ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> if balanced</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></td>
</tr>
<tr>
<td>Red Black Tree</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext>&nbsp;</mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m * log ~ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.03588em;">g</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></td>
</tr>
<tr>
<td>Trie</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> - Only have to compare each letter</td>
<td><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> if no common prefixes; closer to <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> depending on the amount of prefix commonality</td>
</tr>
</tbody>
</table><p>If the number of strings <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> keeps increasing, the performance of the Trie will improve over the Red Black Tree.  However, it won’t improve by much since the Red Black Tree is logarithmic.  If the size of the string length <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">m</span></span></span></span></span> is larger, then we will see more noticeable improvements from the Trie over the Red Black Tree.  The Trie is definitely faster than the List or Binary Search Tree.</p>
<p>The memory requirements of the Trie vary based on the amount of compression we get from having common character prefixes.  In the problem set below, you will compare the memory requirements of a collection of phone numbers stored in a List and stored in a Trie.  Phone numbers for a specific geographical region will have common area codes and exchanges.  Similar situations occur with IP addresses in a network.</p>
<p>To measure the memory requirement of a variable in Erlang, we use the following code:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token variable">List</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token variable">Size</span> <span class="token operator">=</span> <span class="token atom">erts_debug</span><span class="token punctuation">:</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token variable">List</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token atom">io</span><span class="token punctuation">:</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Size of List = ~p~n"</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token variable">Size</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</code></pre>
<h2 id="problem-set-3">Problem Set 3</h2>
<ol>
<li>Download the file <a href="https://macbeth-byui.github.io/cse382-course/proves/phone.txt">phone.txt</a> for use in this problem.  This file contains a list of 80,000 phone numbers with the same area code and eight different exchanges (the 3 digits after the area code).  To increase the size of the common prefix, the international code (+1) along with dashes have been included.  Write test code to compare the memory sizes of these phone number strings stored in both a list and in a Trie.  Note that it may take several minutes to create the Trie.  The function <code>read_file</code> has been provided for you which will store each line of the file into an erlang list.  Record your observations in the comments of the test code including the following:
<ul>
<li>Percentage reduction obtained by using a Trie</li>
<li>Reason for the reduction</li>
</ul>
</li>
</ol>

    </div>
  </div>
</body>

</html>
